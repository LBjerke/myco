const log = std.log.scoped(.server);
const std = @import("std");
const Nix = @import("nix.zig").Nix;
const UX = @import("ux.zig").UX;
const Config = @import("config.zig");
const Systemd = @import("systemd.zig");
const http = std.http;
const mem = std.mem;
const net = std.net;

// TODO: create router for the server
// Woot I figured out how to read the body from a request
// Local sleep helper (copies logic from ux.zig for simplicity in main)
pub fn main() !void {
    var gpa = std.heap.DebugAllocator(.{}){};
    defer _ = gpa.deinit(); // Ensure all memory is freed at the end of `main`.

    // Get the allocator interface from the gpa.
    const allocator = gpa.allocator();
    // Prints to stderr, ignoring potential errors.
    //this is the zimq part
    var ux = UX.init(allocator);
    defer ux.deinit();

      var loader = Config.ConfigLoader.init(allocator);
    defer loader.deinit();

    // 2. Load Configs
    try ux.step("Loading services from ./services/", .{});
    const configs = try loader.loadAll("services");
    
    if (configs.len == 0) {
        ux.success("No services found in ./services/. Exiting.", .{});
        return;
    }
    
    ux.success("Found {d} service(s)", .{configs.len});
    // 1. Start action
for (configs) |svc| {

    // FIX: Use local sleep

     try ux.step("Building {s} ({s})", .{svc.name, svc.package});
    var new_nix = Nix.init(allocator);
    new_nix.proprietary_software = true;
    const store_path = new_nix.build( svc.package) catch |err| {
            ux.fail("Build failed: {}", .{err});
            continue;
        };
      defer allocator.free(store_path);
        
        ux.success("Built {s}", .{svc.name});

        try ux.step("Starting {s}", .{svc.name});
        
        // Call Real Systemd
        Systemd.apply(allocator, svc, store_path) catch |err| {
            ux.fail("Start failed: {}", .{err});
            continue;
        };
        
        ux.success("{s} is running!", .{svc.name});
//    ux.fail("Permission denied writing to /run/systemd/system", .{});
}

    const address = try std.net.Address.parseIp4("127.0.0.1", 8080);
    var server = try address.listen(.{});
    defer server.deinit();

    while (true) {
        const conn = try server.accept();
        defer conn.stream.close();

        var reader_buf: [1024]u8 = undefined;
        var writer_buf: [1024]u8 = undefined;

        var reader = conn.stream.reader(&reader_buf).file_reader;
        var writer = conn.stream.writer(&writer_buf).file_writer;

        var server_http = std.http.Server.init(&reader.interface, &writer.interface);

        var req = try server_http.receiveHead();
        if (mem.eql(u8, req.head.target, "/hello")) {
            // Example: Read request body

            const body = try (try req.readerExpectContinue(&.{})).allocRemaining(allocator, .unlimited);
            defer allocator.free(body);
            std.debug.print("Request body: {s}\n", .{body});

            try req.respond("it works", .{});
        } else {
            try req.respond("hello!", .{});
        }
    }
}
test "simple test" {
    const gpa = std.testing.allocator;
    var list: std.ArrayList(i32) = .empty;
    defer list.deinit(gpa); // Try commenting this out and see if zig detects the memory leak!
    try list.append(gpa, 42);
    try std.testing.expectEqual(@as(i32, 42), list.pop());
}

test "fuzz example" {
    const context = struct {
        fn testOne(context: @This(), input: []const u8) anyerror!void {
            _ = context;
            if (input.len > 0) {
                // Try passing `--fuzz` to `zig build test` and see if it manages to fail this test case!
                try std.testing.expect(!std.mem.eql(u8, input, input));
            }
        }
    };
    try std.testing.fuzz(context{}, context.testOne, .{});
}
fn generateUnitContent(allocator: std.mem.Allocator, name: []const u8, store_path: []const u8) ![]u8 {
    // For the MVP, we assume the binary name matches the package name.
    // In the future, your '.zon' file will define the specific 'cmd'.

    // Construct the full binary path: /nix/store/.../bin/<name>
    // e.g. /nix/store/...-redis/bin/redis-server
    // Note: For redis specifically, the package is 'redis', but binary is 'redis-server'.
    // We will hardcode 'redis-server' for this example, but usually this comes from config.
    const binary_name = if (std.mem.eql(u8, name, "redis")) "redis-server" else name;

    return std.fmt.allocPrint(allocator,
        \\[Unit]
        \\Description=Myco Managed Service: {s}
        \\After=network.target
        \\
        \\[Service]
        \\# SECURITY: Run as a dynamic transient user, not root
        \\DynamicUser=yes
        \\
        \\# STATE: Systemd manages this directory at /var/lib/myco/{s}
        \\StateDirectory=myco/{s}
        \\WorkingDirectory=/var/lib/myco/{s}
        \\
        \\# ISOLATION: Prevent the app from writing to the OS (except StateDirectory)
        \\ProtectSystem=strict
        \\ProtectHome=yes
        \\PrivateTmp=yes
        \\
        \\# EXECUTION
        \\ExecStart={s}/bin/{s}
        \\Restart=always
        \\
        \\[Install]
        \\WantedBy=multi-user.target
        \\
    , .{ name, name, name, name, store_path, binary_name });
}
fn installAndStart(allocator: std.mem.Allocator, name: []const u8, unit_content: []const u8) !void {
    const filename = try std.fmt.allocPrint(allocator, "myco-{s}.service", .{name});
    defer allocator.free(filename);

    // 1. Write the Unit File
    // We write to /etc/systemd/system/ so it persists (or use /run/systemd/system for transient)
    const install_path = "/run/systemd/system";

    const full_path = try std.fs.path.join(allocator, &[_][]const u8{ install_path, filename });
    defer allocator.free(full_path);

    std.debug.print("Writing unit file to {s}...\n", .{full_path});

    const file = try std.fs.createFileAbsolute(full_path, .{});
    defer file.close();
    try file.writeAll(unit_content);

    // 2. Reload Systemd (so it sees the new file)
    try runCommand(allocator, &[_][]const u8{ "systemctl", "daemon-reload" });

    // 3. Start the Service
    // The service name is "myco-redis"
    const service_name = try std.fmt.allocPrint(allocator, "myco-{s}", .{name});
    defer allocator.free(service_name);

    std.debug.print("Starting service {s}...\n", .{service_name});
    try runCommand(allocator, &[_][]const u8{ "systemctl", "start", service_name });
}

// Helper to run simple commands (like systemctl)
fn runCommand(allocator: std.mem.Allocator, argv: []const []const u8) !void {
    var child = std.process.Child.init(argv, allocator);
    child.stdout_behavior = .Inherit;
    child.stderr_behavior = .Inherit;

    const term = try child.spawnAndWait();

    switch (term) {
        .Exited => |code| {
            if (code != 0) return error.CommandFailed;
        },
        else => return error.CommandCrashed,
    }
}
